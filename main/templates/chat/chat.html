{% extends 'main/base.html' %}
{% block title %}Chat with {{ other_user.username }} | AHMES Secondary School{% endblock %}
{% load static %}
{% block content %}
<section class="section">
  <div class="container">
    <h2 class="section-title">Chat with {{ other_user.username }}</h2>
    <p class="section-subtitle">Send and receive messages in real-time.</p>
    
    <div class="row">
      <div class="col-12">
        <div class="card" data-aos="fade-up">
          <div class="card-body" id="messageContainer" style="max-height: 500px; overflow-y: auto;">
            {% for message in conversation.messages.all %}
              <div class="mb-3 {% if message.sender == request.user %}text-end{% else %}text-start{% endif %}" id="message-{{ message.id }}" data-sender-id="{{ message.sender.id }}">
                <div class="d-inline-block p-3 rounded" style="background: {% if message.sender == request.user %}#e6f3ff{% else %}#f8f9fa{% endif %}; max-width: 70%;">
                  <p class="mb-1">{{ message.content }}</p>
                  <small class="text-muted">
                    {{ message.timestamp|time:"H:i" }}  <!-- Changed to time only format -->
                    {% if message.sender == request.user %}
                      <span class="read-status" data-message-id="{{ message.id }}">
                        {% if message.is_read %}
                          <i class="fas fa-check-double text-primary" title="Read"></i>
                        {% else %}
                          <i class="fas fa-check text-muted" title="Sent"></i>
                        {% endif %}
                      </span>
                    {% endif %}
                  </small>
                </div>
              </div>
            {% endfor %}
          </div>
          <div class="card-footer">
            <form method="post" action="{% url 'chat' conversation.id %}" id="messageForm">
              {% csrf_token %}
              <div class="input-group">
                <input type="text" name="content" class="form-control" placeholder="Type your message..." required id="messageInput">
                <button type="submit" class="btn btn-primary">Send</button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>
  </div>
</section>
{% endblock %}

{% block extra_js %}
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

<!-- Audio elements for sound effects (hidden) -->
<audio id="sendSound" preload="auto">
  <source src="{% static 'audio/send.mp3' %} " type="audio/mpeg">
</audio>
<audio id="receiveSound" preload="auto">
  <source src="{% static 'audio/receive.mp3' %}" type="audio/mpeg">
</audio>

<script>
document.addEventListener("DOMContentLoaded", function() {
  const messageForm = document.getElementById("messageForm");
  const messageInput = document.getElementById("messageInput");
  const messageContainer = document.getElementById("messageContainer");
  let lastMessageId = {{ conversation.messages.last.id|default:0 }};
  let isWindowFocused = true;
  const currentUserId = {{ request.user.id }};
  const otherUserId = {{ other_user.id }};
  
  // Sound elements
  const sendSound = document.getElementById('sendSound');
  const receiveSound = document.getElementById('receiveSound');
  
  // Volume settings (adjust as needed)
  sendSound.volume = 0.3;
  receiveSound.volume = 0.3;
  
  window.addEventListener('focus', () => { isWindowFocused = true; });
  window.addEventListener('blur', () => { isWindowFocused = false; });

  function scrollToBottom() {
    messageContainer.scrollTop = messageContainer.scrollHeight;
  }

  function formatTime(date) {
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    return `${hours}:${minutes}`;
  }

  function createMessageElement(data) {
    const isMe = data.sender_id === currentUserId;
    const date = new Date(data.timestamp);
    const formattedTime = formatTime(date);
    
    const messageDiv = document.createElement('div');
    messageDiv.className = `mb-3 ${isMe ? 'text-end' : 'text-start'}`;
    messageDiv.id = `message-${data.id}`;
    messageDiv.dataset.senderId = data.sender_id;
    
    const messageContent = document.createElement('div');
    messageContent.className = 'd-inline-block p-3 rounded';
    messageContent.style.background = isMe ? '#e6f3ff' : '#f8f9fa';
    messageContent.style.maxWidth = '70%';
    
    const messageText = document.createElement('p');
    messageText.className = 'mb-1';
    messageText.textContent = data.content;
    
    const messageTime = document.createElement('small');
    messageTime.className = 'text-muted';
    messageTime.textContent = formattedTime;
    
    if (isMe) {
      const readStatus = document.createElement('span');
      readStatus.className = 'read-status';
      readStatus.dataset.messageId = data.id;
      
      const checkIcon = document.createElement('i');
      checkIcon.className = data.is_read ? 'fas fa-check-double text-primary' : 'fas fa-check text-muted';
      checkIcon.title = data.is_read ? 'Read' : 'Sent';
      
      readStatus.appendChild(document.createTextNode(' '));
      readStatus.appendChild(checkIcon);
      messageTime.appendChild(readStatus);
    }
    
    messageContent.appendChild(messageText);
    messageContent.appendChild(messageTime);
    messageDiv.appendChild(messageContent);
    
    return messageDiv;
  }

  async function markMessagesAsRead(messageIds) {
    if (!messageIds.length) return;
    try {
      const response = await fetch('{% url "mark_messages_read" %}', {
        method: "POST",
        headers: {
          "X-CSRFToken": "{{ csrf_token }}",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ message_ids: messageIds })
      });
      if (!response.ok) {
        throw new Error('Failed to mark messages as read');
      }
    } catch (error) {
      console.error('Error marking messages as read:', error);
    }
  }

  function updateReadStatus(messageId) {
    const messageElement = document.getElementById(`message-${messageId}`);
    if (messageElement) {
      const checkIcon = messageElement.querySelector('.read-status i');
      if (checkIcon && checkIcon.className !== 'fas fa-check-double text-primary') {
        checkIcon.className = 'fas fa-check-double text-primary';
        checkIcon.title = 'Read';
      }
    }
  }

  async function checkNewMessagesAndReadStatus() {
    try {
      const response = await fetch(`/conversations/{{ conversation.id }}/messages/?last_id=${lastMessageId}`);
      const data = await response.json();
      
      if (data.messages?.length) {
        let shouldScroll = false;
        let messagesToMarkRead = [];
        let newMessagesReceived = false;
        
        for (const msg of data.messages) {
          const existingElement = document.getElementById(`message-${msg.id}`);
          
          if (!existingElement) {
            // New message - add to chat
            const element = createMessageElement({
              id: msg.id,
              content: msg.content,
              timestamp: msg.timestamp,
              sender_id: msg.is_me ? currentUserId : otherUserId,
              is_read: msg.is_read
            });
            messageContainer.appendChild(element);
            lastMessageId = Math.max(lastMessageId, msg.id);
            shouldScroll = true;
            
            // Play sound for new received messages (not sent by current user)
            if (!msg.is_me) {
              newMessagesReceived = true;
            }
            
            // Collect messages to mark as read
            if (!msg.is_me && !msg.is_read && isWindowFocused) {
              messagesToMarkRead.push(msg.id);
            }
          } else if (msg.is_me && msg.is_read) {
            // Update read status for our messages
            updateReadStatus(msg.id);
          }
        }
        
        // Play receive sound if new messages were received
        if (newMessagesReceived && isWindowFocused) {
          receiveSound.currentTime = 0; // Rewind to start
          receiveSound.play().catch(e => console.log("Audio play failed:", e));
        }
        
        // Mark messages as read in bulk
        if (messagesToMarkRead.length) {
          await markMessagesAsRead(messagesToMarkRead);
        }
        
        if (shouldScroll) {
          scrollToBottom();
        }
      }
    } catch (error) {
      console.error('Error checking messages:', error);
    }
  }

  async function checkAllMessagesReadStatus() {
    try {
      // Fetch all messages to check read status
      const response = await fetch(`/conversations/{{ conversation.id }}/messages/?last_id=0`);
      const data = await response.json();
      
      if (data.messages?.length) {
        for (const msg of data.messages) {
          if (msg.is_me && msg.is_read) {
            updateReadStatus(msg.id);
          }
        }
      }
    } catch (error) {
      console.error('Error checking read status:', error);
    }
  }

  messageForm?.addEventListener("submit", async function(e) {
    e.preventDefault();
    const formData = new FormData(this);
    
    try {
      const response = await fetch(this.action, {
        method: "POST",
        body: formData,
        headers: {
          "X-Requested-With": "XMLHttpRequest",
        },
      });
      const data = await response.json();
      
      if (data.success) {
        const element = createMessageElement({
          id: data.message_id,
          content: data.content,
          timestamp: data.timestamp,
          sender_id: currentUserId,
          is_read: false
        });
        messageContainer.appendChild(element);
        messageInput.value = '';
        scrollToBottom();
        
        // Play send sound
        sendSound.currentTime = 0; // Rewind to start
        sendSound.play().catch(e => console.log("Audio play failed:", e));
      }
    } catch (error) {
      console.error('Error sending message:', error);
    }
  });

  // Check messages and read status every 2 seconds when focused, 5 seconds when not
  setInterval(() => {
    checkNewMessagesAndReadStatus();
    checkAllMessagesReadStatus();
  }, isWindowFocused ? 2000 : 5000);

  checkNewMessagesAndReadStatus();
  checkAllMessagesReadStatus();
  scrollToBottom();
});
</script>

<style>
.read-status i {
  margin-left: 5px;
}

/* Hide audio elements */
audio {
  display: none;
}
</style>
{% endblock %}